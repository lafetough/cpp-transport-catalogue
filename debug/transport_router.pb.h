// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transport_router.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transport_5frouter_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transport_5frouter_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "graph.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transport_5frouter_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transport_5frouter_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transport_5frouter_2eproto;
namespace serial {
class BusEdge;
struct BusEdgeDefaultTypeInternal;
extern BusEdgeDefaultTypeInternal _BusEdge_default_instance_;
class EdgeInfo;
struct EdgeInfoDefaultTypeInternal;
extern EdgeInfoDefaultTypeInternal _EdgeInfo_default_instance_;
class RouteInternalData;
struct RouteInternalDataDefaultTypeInternal;
extern RouteInternalDataDefaultTypeInternal _RouteInternalData_default_instance_;
class RouteInternalData_EdgeId;
struct RouteInternalData_EdgeIdDefaultTypeInternal;
extern RouteInternalData_EdgeIdDefaultTypeInternal _RouteInternalData_EdgeId_default_instance_;
class Router;
struct RouterDefaultTypeInternal;
extern RouterDefaultTypeInternal _Router_default_instance_;
class RoutesInternalData;
struct RoutesInternalDataDefaultTypeInternal;
extern RoutesInternalDataDefaultTypeInternal _RoutesInternalData_default_instance_;
class RoutingSettings;
struct RoutingSettingsDefaultTypeInternal;
extern RoutingSettingsDefaultTypeInternal _RoutingSettings_default_instance_;
class StopGraphContain;
struct StopGraphContainDefaultTypeInternal;
extern StopGraphContainDefaultTypeInternal _StopGraphContain_default_instance_;
class TransportRouter;
struct TransportRouterDefaultTypeInternal;
extern TransportRouterDefaultTypeInternal _TransportRouter_default_instance_;
class TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse;
struct TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUseDefaultTypeInternal;
extern TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUseDefaultTypeInternal _TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse_default_instance_;
class TransportRouter_StopsVertexContEntry_DoNotUse;
struct TransportRouter_StopsVertexContEntry_DoNotUseDefaultTypeInternal;
extern TransportRouter_StopsVertexContEntry_DoNotUseDefaultTypeInternal _TransportRouter_StopsVertexContEntry_DoNotUse_default_instance_;
class WaitEdge;
struct WaitEdgeDefaultTypeInternal;
extern WaitEdgeDefaultTypeInternal _WaitEdge_default_instance_;
}  // namespace serial
PROTOBUF_NAMESPACE_OPEN
template<> ::serial::BusEdge* Arena::CreateMaybeMessage<::serial::BusEdge>(Arena*);
template<> ::serial::EdgeInfo* Arena::CreateMaybeMessage<::serial::EdgeInfo>(Arena*);
template<> ::serial::RouteInternalData* Arena::CreateMaybeMessage<::serial::RouteInternalData>(Arena*);
template<> ::serial::RouteInternalData_EdgeId* Arena::CreateMaybeMessage<::serial::RouteInternalData_EdgeId>(Arena*);
template<> ::serial::Router* Arena::CreateMaybeMessage<::serial::Router>(Arena*);
template<> ::serial::RoutesInternalData* Arena::CreateMaybeMessage<::serial::RoutesInternalData>(Arena*);
template<> ::serial::RoutingSettings* Arena::CreateMaybeMessage<::serial::RoutingSettings>(Arena*);
template<> ::serial::StopGraphContain* Arena::CreateMaybeMessage<::serial::StopGraphContain>(Arena*);
template<> ::serial::TransportRouter* Arena::CreateMaybeMessage<::serial::TransportRouter>(Arena*);
template<> ::serial::TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse* Arena::CreateMaybeMessage<::serial::TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse>(Arena*);
template<> ::serial::TransportRouter_StopsVertexContEntry_DoNotUse* Arena::CreateMaybeMessage<::serial::TransportRouter_StopsVertexContEntry_DoNotUse>(Arena*);
template<> ::serial::WaitEdge* Arena::CreateMaybeMessage<::serial::WaitEdge>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace serial {

// ===================================================================

class RoutingSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.RoutingSettings) */ {
 public:
  inline RoutingSettings() : RoutingSettings(nullptr) {}
  ~RoutingSettings() override;
  explicit constexpr RoutingSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutingSettings(const RoutingSettings& from);
  RoutingSettings(RoutingSettings&& from) noexcept
    : RoutingSettings() {
    *this = ::std::move(from);
  }

  inline RoutingSettings& operator=(const RoutingSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingSettings& operator=(RoutingSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutingSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutingSettings* internal_default_instance() {
    return reinterpret_cast<const RoutingSettings*>(
               &_RoutingSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RoutingSettings& a, RoutingSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingSettings* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoutingSettings* New() const final {
    return new RoutingSettings();
  }

  RoutingSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutingSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutingSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutingSettings& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.RoutingSettings";
  }
  protected:
  explicit RoutingSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBusVelocityFieldNumber = 1,
    kBusWaitTimeFieldNumber = 2,
  };
  // int32 bus_velocity = 1;
  void clear_bus_velocity();
  ::PROTOBUF_NAMESPACE_ID::int32 bus_velocity() const;
  void set_bus_velocity(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bus_velocity() const;
  void _internal_set_bus_velocity(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 bus_wait_time = 2;
  void clear_bus_wait_time();
  ::PROTOBUF_NAMESPACE_ID::int32 bus_wait_time() const;
  void set_bus_wait_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bus_wait_time() const;
  void _internal_set_bus_wait_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:serial.RoutingSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 bus_velocity_;
  ::PROTOBUF_NAMESPACE_ID::int32 bus_wait_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class RouteInternalData_EdgeId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.RouteInternalData.EdgeId) */ {
 public:
  inline RouteInternalData_EdgeId() : RouteInternalData_EdgeId(nullptr) {}
  ~RouteInternalData_EdgeId() override;
  explicit constexpr RouteInternalData_EdgeId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteInternalData_EdgeId(const RouteInternalData_EdgeId& from);
  RouteInternalData_EdgeId(RouteInternalData_EdgeId&& from) noexcept
    : RouteInternalData_EdgeId() {
    *this = ::std::move(from);
  }

  inline RouteInternalData_EdgeId& operator=(const RouteInternalData_EdgeId& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteInternalData_EdgeId& operator=(RouteInternalData_EdgeId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteInternalData_EdgeId& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteInternalData_EdgeId* internal_default_instance() {
    return reinterpret_cast<const RouteInternalData_EdgeId*>(
               &_RouteInternalData_EdgeId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RouteInternalData_EdgeId& a, RouteInternalData_EdgeId& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteInternalData_EdgeId* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteInternalData_EdgeId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteInternalData_EdgeId* New() const final {
    return new RouteInternalData_EdgeId();
  }

  RouteInternalData_EdgeId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteInternalData_EdgeId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteInternalData_EdgeId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteInternalData_EdgeId& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteInternalData_EdgeId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.RouteInternalData.EdgeId";
  }
  protected:
  explicit RouteInternalData_EdgeId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint64 value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:serial.RouteInternalData.EdgeId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class RouteInternalData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.RouteInternalData) */ {
 public:
  inline RouteInternalData() : RouteInternalData(nullptr) {}
  ~RouteInternalData() override;
  explicit constexpr RouteInternalData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteInternalData(const RouteInternalData& from);
  RouteInternalData(RouteInternalData&& from) noexcept
    : RouteInternalData() {
    *this = ::std::move(from);
  }

  inline RouteInternalData& operator=(const RouteInternalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteInternalData& operator=(RouteInternalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteInternalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteInternalData* internal_default_instance() {
    return reinterpret_cast<const RouteInternalData*>(
               &_RouteInternalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RouteInternalData& a, RouteInternalData& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteInternalData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteInternalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteInternalData* New() const final {
    return new RouteInternalData();
  }

  RouteInternalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteInternalData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteInternalData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteInternalData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteInternalData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.RouteInternalData";
  }
  protected:
  explicit RouteInternalData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RouteInternalData_EdgeId EdgeId;

  // accessors -------------------------------------------------------

  enum : int {
    kPrevEdgeIdFieldNumber = 2,
    kWeightValFieldNumber = 1,
  };
  // .serial.RouteInternalData.EdgeId prev_edge_id = 2;
  bool has_prev_edge_id() const;
  private:
  bool _internal_has_prev_edge_id() const;
  public:
  void clear_prev_edge_id();
  const ::serial::RouteInternalData_EdgeId& prev_edge_id() const;
  PROTOBUF_MUST_USE_RESULT ::serial::RouteInternalData_EdgeId* release_prev_edge_id();
  ::serial::RouteInternalData_EdgeId* mutable_prev_edge_id();
  void set_allocated_prev_edge_id(::serial::RouteInternalData_EdgeId* prev_edge_id);
  private:
  const ::serial::RouteInternalData_EdgeId& _internal_prev_edge_id() const;
  ::serial::RouteInternalData_EdgeId* _internal_mutable_prev_edge_id();
  public:
  void unsafe_arena_set_allocated_prev_edge_id(
      ::serial::RouteInternalData_EdgeId* prev_edge_id);
  ::serial::RouteInternalData_EdgeId* unsafe_arena_release_prev_edge_id();

  // double weight_val = 1;
  void clear_weight_val();
  double weight_val() const;
  void set_weight_val(double value);
  private:
  double _internal_weight_val() const;
  void _internal_set_weight_val(double value);
  public:

  // @@protoc_insertion_point(class_scope:serial.RouteInternalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::serial::RouteInternalData_EdgeId* prev_edge_id_;
  double weight_val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class RoutesInternalData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.RoutesInternalData) */ {
 public:
  inline RoutesInternalData() : RoutesInternalData(nullptr) {}
  ~RoutesInternalData() override;
  explicit constexpr RoutesInternalData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoutesInternalData(const RoutesInternalData& from);
  RoutesInternalData(RoutesInternalData&& from) noexcept
    : RoutesInternalData() {
    *this = ::std::move(from);
  }

  inline RoutesInternalData& operator=(const RoutesInternalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutesInternalData& operator=(RoutesInternalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoutesInternalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoutesInternalData* internal_default_instance() {
    return reinterpret_cast<const RoutesInternalData*>(
               &_RoutesInternalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoutesInternalData& a, RoutesInternalData& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutesInternalData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutesInternalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoutesInternalData* New() const final {
    return new RoutesInternalData();
  }

  RoutesInternalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutesInternalData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoutesInternalData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoutesInternalData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutesInternalData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.RoutesInternalData";
  }
  protected:
  explicit RoutesInternalData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .serial.RouteInternalData value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::serial::RouteInternalData* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RouteInternalData >*
      mutable_value();
  private:
  const ::serial::RouteInternalData& _internal_value(int index) const;
  ::serial::RouteInternalData* _internal_add_value();
  public:
  const ::serial::RouteInternalData& value(int index) const;
  ::serial::RouteInternalData* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RouteInternalData >&
      value() const;

  // @@protoc_insertion_point(class_scope:serial.RoutesInternalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RouteInternalData > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class Router final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.Router) */ {
 public:
  inline Router() : Router(nullptr) {}
  ~Router() override;
  explicit constexpr Router(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Router(const Router& from);
  Router(Router&& from) noexcept
    : Router() {
    *this = ::std::move(from);
  }

  inline Router& operator=(const Router& from) {
    CopyFrom(from);
    return *this;
  }
  inline Router& operator=(Router&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Router& default_instance() {
    return *internal_default_instance();
  }
  static inline const Router* internal_default_instance() {
    return reinterpret_cast<const Router*>(
               &_Router_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Router& a, Router& b) {
    a.Swap(&b);
  }
  inline void Swap(Router* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Router* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Router* New() const final {
    return new Router();
  }

  Router* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Router>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Router& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Router& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Router* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.Router";
  }
  protected:
  explicit Router(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesInternalDataFieldNumber = 2,
    kGraphFieldNumber = 1,
  };
  // repeated .serial.RoutesInternalData routes_internal_data = 2;
  int routes_internal_data_size() const;
  private:
  int _internal_routes_internal_data_size() const;
  public:
  void clear_routes_internal_data();
  ::serial::RoutesInternalData* mutable_routes_internal_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RoutesInternalData >*
      mutable_routes_internal_data();
  private:
  const ::serial::RoutesInternalData& _internal_routes_internal_data(int index) const;
  ::serial::RoutesInternalData* _internal_add_routes_internal_data();
  public:
  const ::serial::RoutesInternalData& routes_internal_data(int index) const;
  ::serial::RoutesInternalData* add_routes_internal_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RoutesInternalData >&
      routes_internal_data() const;

  // .serial.Graph graph = 1;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::serial::Graph& graph() const;
  PROTOBUF_MUST_USE_RESULT ::serial::Graph* release_graph();
  ::serial::Graph* mutable_graph();
  void set_allocated_graph(::serial::Graph* graph);
  private:
  const ::serial::Graph& _internal_graph() const;
  ::serial::Graph* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::serial::Graph* graph);
  ::serial::Graph* unsafe_arena_release_graph();

  // @@protoc_insertion_point(class_scope:serial.Router)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RoutesInternalData > routes_internal_data_;
  ::serial::Graph* graph_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class WaitEdge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.WaitEdge) */ {
 public:
  inline WaitEdge() : WaitEdge(nullptr) {}
  ~WaitEdge() override;
  explicit constexpr WaitEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WaitEdge(const WaitEdge& from);
  WaitEdge(WaitEdge&& from) noexcept
    : WaitEdge() {
    *this = ::std::move(from);
  }

  inline WaitEdge& operator=(const WaitEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline WaitEdge& operator=(WaitEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WaitEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const WaitEdge* internal_default_instance() {
    return reinterpret_cast<const WaitEdge*>(
               &_WaitEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WaitEdge& a, WaitEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(WaitEdge* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WaitEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WaitEdge* New() const final {
    return new WaitEdge();
  }

  WaitEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WaitEdge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WaitEdge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WaitEdge& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.WaitEdge";
  }
  protected:
  explicit WaitEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopNameFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // string stop_name = 1;
  void clear_stop_name();
  const std::string& stop_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_stop_name();
  void set_allocated_stop_name(std::string* stop_name);
  private:
  const std::string& _internal_stop_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_name(const std::string& value);
  std::string* _internal_mutable_stop_name();
  public:

  // double time = 2;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:serial.WaitEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_name_;
  double time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class StopGraphContain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.StopGraphContain) */ {
 public:
  inline StopGraphContain() : StopGraphContain(nullptr) {}
  ~StopGraphContain() override;
  explicit constexpr StopGraphContain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopGraphContain(const StopGraphContain& from);
  StopGraphContain(StopGraphContain&& from) noexcept
    : StopGraphContain() {
    *this = ::std::move(from);
  }

  inline StopGraphContain& operator=(const StopGraphContain& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopGraphContain& operator=(StopGraphContain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopGraphContain& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopGraphContain* internal_default_instance() {
    return reinterpret_cast<const StopGraphContain*>(
               &_StopGraphContain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StopGraphContain& a, StopGraphContain& b) {
    a.Swap(&b);
  }
  inline void Swap(StopGraphContain* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopGraphContain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopGraphContain* New() const final {
    return new StopGraphContain();
  }

  StopGraphContain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopGraphContain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopGraphContain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopGraphContain& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopGraphContain* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.StopGraphContain";
  }
  protected:
  explicit StopGraphContain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartWaitingFieldNumber = 2,
    kEndWaitingFieldNumber = 3,
  };
  // uint32 start_waiting = 2;
  void clear_start_waiting();
  ::PROTOBUF_NAMESPACE_ID::uint32 start_waiting() const;
  void set_start_waiting(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_start_waiting() const;
  void _internal_set_start_waiting(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 end_waiting = 3;
  void clear_end_waiting();
  ::PROTOBUF_NAMESPACE_ID::uint32 end_waiting() const;
  void set_end_waiting(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_end_waiting() const;
  void _internal_set_end_waiting(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:serial.StopGraphContain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 start_waiting_;
  ::PROTOBUF_NAMESPACE_ID::uint32 end_waiting_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class BusEdge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.BusEdge) */ {
 public:
  inline BusEdge() : BusEdge(nullptr) {}
  ~BusEdge() override;
  explicit constexpr BusEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BusEdge(const BusEdge& from);
  BusEdge(BusEdge&& from) noexcept
    : BusEdge() {
    *this = ::std::move(from);
  }

  inline BusEdge& operator=(const BusEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline BusEdge& operator=(BusEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BusEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const BusEdge* internal_default_instance() {
    return reinterpret_cast<const BusEdge*>(
               &_BusEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BusEdge& a, BusEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(BusEdge* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BusEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BusEdge* New() const final {
    return new BusEdge();
  }

  BusEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BusEdge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BusEdge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BusEdge& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BusEdge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.BusEdge";
  }
  protected:
  explicit BusEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBusNameFieldNumber = 1,
    kTimeFieldNumber = 3,
    kSpanCountFieldNumber = 2,
  };
  // string bus_name = 1;
  void clear_bus_name();
  const std::string& bus_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bus_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bus_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_bus_name();
  void set_allocated_bus_name(std::string* bus_name);
  private:
  const std::string& _internal_bus_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bus_name(const std::string& value);
  std::string* _internal_mutable_bus_name();
  public:

  // double time = 3;
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // uint32 span_count = 2;
  void clear_span_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 span_count() const;
  void set_span_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_span_count() const;
  void _internal_set_span_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:serial.BusEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bus_name_;
  double time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 span_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class EdgeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.EdgeInfo) */ {
 public:
  inline EdgeInfo() : EdgeInfo(nullptr) {}
  ~EdgeInfo() override;
  explicit constexpr EdgeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgeInfo(const EdgeInfo& from);
  EdgeInfo(EdgeInfo&& from) noexcept
    : EdgeInfo() {
    *this = ::std::move(from);
  }

  inline EdgeInfo& operator=(const EdgeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeInfo& operator=(EdgeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdgeInfo& default_instance() {
    return *internal_default_instance();
  }
  enum InfoCase {
    kWE = 1,
    kBE = 2,
    INFO_NOT_SET = 0,
  };

  static inline const EdgeInfo* internal_default_instance() {
    return reinterpret_cast<const EdgeInfo*>(
               &_EdgeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EdgeInfo& a, EdgeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(EdgeInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EdgeInfo* New() const final {
    return new EdgeInfo();
  }

  EdgeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EdgeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdgeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EdgeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.EdgeInfo";
  }
  protected:
  explicit EdgeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWEFieldNumber = 1,
    kBEFieldNumber = 2,
  };
  // .serial.WaitEdge w_e = 1;
  bool has_w_e() const;
  private:
  bool _internal_has_w_e() const;
  public:
  void clear_w_e();
  const ::serial::WaitEdge& w_e() const;
  PROTOBUF_MUST_USE_RESULT ::serial::WaitEdge* release_w_e();
  ::serial::WaitEdge* mutable_w_e();
  void set_allocated_w_e(::serial::WaitEdge* w_e);
  private:
  const ::serial::WaitEdge& _internal_w_e() const;
  ::serial::WaitEdge* _internal_mutable_w_e();
  public:
  void unsafe_arena_set_allocated_w_e(
      ::serial::WaitEdge* w_e);
  ::serial::WaitEdge* unsafe_arena_release_w_e();

  // .serial.BusEdge b_e = 2;
  bool has_b_e() const;
  private:
  bool _internal_has_b_e() const;
  public:
  void clear_b_e();
  const ::serial::BusEdge& b_e() const;
  PROTOBUF_MUST_USE_RESULT ::serial::BusEdge* release_b_e();
  ::serial::BusEdge* mutable_b_e();
  void set_allocated_b_e(::serial::BusEdge* b_e);
  private:
  const ::serial::BusEdge& _internal_b_e() const;
  ::serial::BusEdge* _internal_mutable_b_e();
  public:
  void unsafe_arena_set_allocated_b_e(
      ::serial::BusEdge* b_e);
  ::serial::BusEdge* unsafe_arena_release_b_e();

  void clear_info();
  InfoCase info_case() const;
  // @@protoc_insertion_point(class_scope:serial.EdgeInfo)
 private:
  class _Internal;
  void set_has_w_e();
  void set_has_b_e();

  inline bool has_info() const;
  inline void clear_has_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union InfoUnion {
    constexpr InfoUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::serial::WaitEdge* w_e_;
    ::serial::BusEdge* b_e_;
  } info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// -------------------------------------------------------------------

class TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse();
  explicit constexpr TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse& other);
  static const TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse*>(&_TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TransportRouter_StopsVertexContEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TransportRouter_StopsVertexContEntry_DoNotUse, 
    std::string, ::serial::StopGraphContain,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TransportRouter_StopsVertexContEntry_DoNotUse, 
    std::string, ::serial::StopGraphContain,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TransportRouter_StopsVertexContEntry_DoNotUse();
  explicit constexpr TransportRouter_StopsVertexContEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TransportRouter_StopsVertexContEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TransportRouter_StopsVertexContEntry_DoNotUse& other);
  static const TransportRouter_StopsVertexContEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TransportRouter_StopsVertexContEntry_DoNotUse*>(&_TransportRouter_StopsVertexContEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "serial.TransportRouter.StopsVertexContEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class TransportRouter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:serial.TransportRouter) */ {
 public:
  inline TransportRouter() : TransportRouter(nullptr) {}
  ~TransportRouter() override;
  explicit constexpr TransportRouter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransportRouter(const TransportRouter& from);
  TransportRouter(TransportRouter&& from) noexcept
    : TransportRouter() {
    *this = ::std::move(from);
  }

  inline TransportRouter& operator=(const TransportRouter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransportRouter& operator=(TransportRouter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransportRouter& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransportRouter* internal_default_instance() {
    return reinterpret_cast<const TransportRouter*>(
               &_TransportRouter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TransportRouter& a, TransportRouter& b) {
    a.Swap(&b);
  }
  inline void Swap(TransportRouter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransportRouter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransportRouter* New() const final {
    return new TransportRouter();
  }

  TransportRouter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransportRouter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransportRouter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransportRouter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransportRouter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "serial.TransportRouter";
  }
  protected:
  explicit TransportRouter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEdgeInfoByEdgeIdFieldNumber = 3,
    kStopsVertexContFieldNumber = 4,
    kRoutingSettingsFieldNumber = 1,
    kRouterFieldNumber = 2,
  };
  // map<uint32, .serial.EdgeInfo> edge_info_by_edge_id = 3;
  int edge_info_by_edge_id_size() const;
  private:
  int _internal_edge_info_by_edge_id_size() const;
  public:
  void clear_edge_info_by_edge_id();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo >&
      _internal_edge_info_by_edge_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo >*
      _internal_mutable_edge_info_by_edge_id();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo >&
      edge_info_by_edge_id() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo >*
      mutable_edge_info_by_edge_id();

  // map<string, .serial.StopGraphContain> stops_vertex_cont = 4;
  int stops_vertex_cont_size() const;
  private:
  int _internal_stops_vertex_cont_size() const;
  public:
  void clear_stops_vertex_cont();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::serial::StopGraphContain >&
      _internal_stops_vertex_cont() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::serial::StopGraphContain >*
      _internal_mutable_stops_vertex_cont();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::serial::StopGraphContain >&
      stops_vertex_cont() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::serial::StopGraphContain >*
      mutable_stops_vertex_cont();

  // .serial.RoutingSettings routing_settings = 1;
  bool has_routing_settings() const;
  private:
  bool _internal_has_routing_settings() const;
  public:
  void clear_routing_settings();
  const ::serial::RoutingSettings& routing_settings() const;
  PROTOBUF_MUST_USE_RESULT ::serial::RoutingSettings* release_routing_settings();
  ::serial::RoutingSettings* mutable_routing_settings();
  void set_allocated_routing_settings(::serial::RoutingSettings* routing_settings);
  private:
  const ::serial::RoutingSettings& _internal_routing_settings() const;
  ::serial::RoutingSettings* _internal_mutable_routing_settings();
  public:
  void unsafe_arena_set_allocated_routing_settings(
      ::serial::RoutingSettings* routing_settings);
  ::serial::RoutingSettings* unsafe_arena_release_routing_settings();

  // .serial.Router router = 2;
  bool has_router() const;
  private:
  bool _internal_has_router() const;
  public:
  void clear_router();
  const ::serial::Router& router() const;
  PROTOBUF_MUST_USE_RESULT ::serial::Router* release_router();
  ::serial::Router* mutable_router();
  void set_allocated_router(::serial::Router* router);
  private:
  const ::serial::Router& _internal_router() const;
  ::serial::Router* _internal_mutable_router();
  public:
  void unsafe_arena_set_allocated_router(
      ::serial::Router* router);
  ::serial::Router* unsafe_arena_release_router();

  // @@protoc_insertion_point(class_scope:serial.TransportRouter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TransportRouter_EdgeInfoByEdgeIdEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> edge_info_by_edge_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TransportRouter_StopsVertexContEntry_DoNotUse,
      std::string, ::serial::StopGraphContain,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> stops_vertex_cont_;
  ::serial::RoutingSettings* routing_settings_;
  ::serial::Router* router_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transport_5frouter_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoutingSettings

// int32 bus_velocity = 1;
inline void RoutingSettings::clear_bus_velocity() {
  bus_velocity_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoutingSettings::_internal_bus_velocity() const {
  return bus_velocity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoutingSettings::bus_velocity() const {
  // @@protoc_insertion_point(field_get:serial.RoutingSettings.bus_velocity)
  return _internal_bus_velocity();
}
inline void RoutingSettings::_internal_set_bus_velocity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  bus_velocity_ = value;
}
inline void RoutingSettings::set_bus_velocity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bus_velocity(value);
  // @@protoc_insertion_point(field_set:serial.RoutingSettings.bus_velocity)
}

// int32 bus_wait_time = 2;
inline void RoutingSettings::clear_bus_wait_time() {
  bus_wait_time_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoutingSettings::_internal_bus_wait_time() const {
  return bus_wait_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoutingSettings::bus_wait_time() const {
  // @@protoc_insertion_point(field_get:serial.RoutingSettings.bus_wait_time)
  return _internal_bus_wait_time();
}
inline void RoutingSettings::_internal_set_bus_wait_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  bus_wait_time_ = value;
}
inline void RoutingSettings::set_bus_wait_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bus_wait_time(value);
  // @@protoc_insertion_point(field_set:serial.RoutingSettings.bus_wait_time)
}

// -------------------------------------------------------------------

// RouteInternalData_EdgeId

// uint64 value = 1;
inline void RouteInternalData_EdgeId::clear_value() {
  value_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RouteInternalData_EdgeId::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RouteInternalData_EdgeId::value() const {
  // @@protoc_insertion_point(field_get:serial.RouteInternalData.EdgeId.value)
  return _internal_value();
}
inline void RouteInternalData_EdgeId::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  value_ = value;
}
inline void RouteInternalData_EdgeId::set_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:serial.RouteInternalData.EdgeId.value)
}

// -------------------------------------------------------------------

// RouteInternalData

// double weight_val = 1;
inline void RouteInternalData::clear_weight_val() {
  weight_val_ = 0;
}
inline double RouteInternalData::_internal_weight_val() const {
  return weight_val_;
}
inline double RouteInternalData::weight_val() const {
  // @@protoc_insertion_point(field_get:serial.RouteInternalData.weight_val)
  return _internal_weight_val();
}
inline void RouteInternalData::_internal_set_weight_val(double value) {
  
  weight_val_ = value;
}
inline void RouteInternalData::set_weight_val(double value) {
  _internal_set_weight_val(value);
  // @@protoc_insertion_point(field_set:serial.RouteInternalData.weight_val)
}

// .serial.RouteInternalData.EdgeId prev_edge_id = 2;
inline bool RouteInternalData::_internal_has_prev_edge_id() const {
  return this != internal_default_instance() && prev_edge_id_ != nullptr;
}
inline bool RouteInternalData::has_prev_edge_id() const {
  return _internal_has_prev_edge_id();
}
inline void RouteInternalData::clear_prev_edge_id() {
  if (GetArenaForAllocation() == nullptr && prev_edge_id_ != nullptr) {
    delete prev_edge_id_;
  }
  prev_edge_id_ = nullptr;
}
inline const ::serial::RouteInternalData_EdgeId& RouteInternalData::_internal_prev_edge_id() const {
  const ::serial::RouteInternalData_EdgeId* p = prev_edge_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::serial::RouteInternalData_EdgeId&>(
      ::serial::_RouteInternalData_EdgeId_default_instance_);
}
inline const ::serial::RouteInternalData_EdgeId& RouteInternalData::prev_edge_id() const {
  // @@protoc_insertion_point(field_get:serial.RouteInternalData.prev_edge_id)
  return _internal_prev_edge_id();
}
inline void RouteInternalData::unsafe_arena_set_allocated_prev_edge_id(
    ::serial::RouteInternalData_EdgeId* prev_edge_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(prev_edge_id_);
  }
  prev_edge_id_ = prev_edge_id;
  if (prev_edge_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serial.RouteInternalData.prev_edge_id)
}
inline ::serial::RouteInternalData_EdgeId* RouteInternalData::release_prev_edge_id() {
  
  ::serial::RouteInternalData_EdgeId* temp = prev_edge_id_;
  prev_edge_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serial::RouteInternalData_EdgeId* RouteInternalData::unsafe_arena_release_prev_edge_id() {
  // @@protoc_insertion_point(field_release:serial.RouteInternalData.prev_edge_id)
  
  ::serial::RouteInternalData_EdgeId* temp = prev_edge_id_;
  prev_edge_id_ = nullptr;
  return temp;
}
inline ::serial::RouteInternalData_EdgeId* RouteInternalData::_internal_mutable_prev_edge_id() {
  
  if (prev_edge_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::serial::RouteInternalData_EdgeId>(GetArenaForAllocation());
    prev_edge_id_ = p;
  }
  return prev_edge_id_;
}
inline ::serial::RouteInternalData_EdgeId* RouteInternalData::mutable_prev_edge_id() {
  ::serial::RouteInternalData_EdgeId* _msg = _internal_mutable_prev_edge_id();
  // @@protoc_insertion_point(field_mutable:serial.RouteInternalData.prev_edge_id)
  return _msg;
}
inline void RouteInternalData::set_allocated_prev_edge_id(::serial::RouteInternalData_EdgeId* prev_edge_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete prev_edge_id_;
  }
  if (prev_edge_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serial::RouteInternalData_EdgeId>::GetOwningArena(prev_edge_id);
    if (message_arena != submessage_arena) {
      prev_edge_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prev_edge_id, submessage_arena);
    }
    
  } else {
    
  }
  prev_edge_id_ = prev_edge_id;
  // @@protoc_insertion_point(field_set_allocated:serial.RouteInternalData.prev_edge_id)
}

// -------------------------------------------------------------------

// RoutesInternalData

// repeated .serial.RouteInternalData value = 1;
inline int RoutesInternalData::_internal_value_size() const {
  return value_.size();
}
inline int RoutesInternalData::value_size() const {
  return _internal_value_size();
}
inline void RoutesInternalData::clear_value() {
  value_.Clear();
}
inline ::serial::RouteInternalData* RoutesInternalData::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:serial.RoutesInternalData.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RouteInternalData >*
RoutesInternalData::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:serial.RoutesInternalData.value)
  return &value_;
}
inline const ::serial::RouteInternalData& RoutesInternalData::_internal_value(int index) const {
  return value_.Get(index);
}
inline const ::serial::RouteInternalData& RoutesInternalData::value(int index) const {
  // @@protoc_insertion_point(field_get:serial.RoutesInternalData.value)
  return _internal_value(index);
}
inline ::serial::RouteInternalData* RoutesInternalData::_internal_add_value() {
  return value_.Add();
}
inline ::serial::RouteInternalData* RoutesInternalData::add_value() {
  ::serial::RouteInternalData* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:serial.RoutesInternalData.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RouteInternalData >&
RoutesInternalData::value() const {
  // @@protoc_insertion_point(field_list:serial.RoutesInternalData.value)
  return value_;
}

// -------------------------------------------------------------------

// Router

// .serial.Graph graph = 1;
inline bool Router::_internal_has_graph() const {
  return this != internal_default_instance() && graph_ != nullptr;
}
inline bool Router::has_graph() const {
  return _internal_has_graph();
}
inline const ::serial::Graph& Router::_internal_graph() const {
  const ::serial::Graph* p = graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::serial::Graph&>(
      ::serial::_Graph_default_instance_);
}
inline const ::serial::Graph& Router::graph() const {
  // @@protoc_insertion_point(field_get:serial.Router.graph)
  return _internal_graph();
}
inline void Router::unsafe_arena_set_allocated_graph(
    ::serial::Graph* graph) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_);
  }
  graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serial.Router.graph)
}
inline ::serial::Graph* Router::release_graph() {
  
  ::serial::Graph* temp = graph_;
  graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serial::Graph* Router::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:serial.Router.graph)
  
  ::serial::Graph* temp = graph_;
  graph_ = nullptr;
  return temp;
}
inline ::serial::Graph* Router::_internal_mutable_graph() {
  
  if (graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::serial::Graph>(GetArenaForAllocation());
    graph_ = p;
  }
  return graph_;
}
inline ::serial::Graph* Router::mutable_graph() {
  ::serial::Graph* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:serial.Router.graph)
  return _msg;
}
inline void Router::set_allocated_graph(::serial::Graph* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_);
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph));
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:serial.Router.graph)
}

// repeated .serial.RoutesInternalData routes_internal_data = 2;
inline int Router::_internal_routes_internal_data_size() const {
  return routes_internal_data_.size();
}
inline int Router::routes_internal_data_size() const {
  return _internal_routes_internal_data_size();
}
inline void Router::clear_routes_internal_data() {
  routes_internal_data_.Clear();
}
inline ::serial::RoutesInternalData* Router::mutable_routes_internal_data(int index) {
  // @@protoc_insertion_point(field_mutable:serial.Router.routes_internal_data)
  return routes_internal_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RoutesInternalData >*
Router::mutable_routes_internal_data() {
  // @@protoc_insertion_point(field_mutable_list:serial.Router.routes_internal_data)
  return &routes_internal_data_;
}
inline const ::serial::RoutesInternalData& Router::_internal_routes_internal_data(int index) const {
  return routes_internal_data_.Get(index);
}
inline const ::serial::RoutesInternalData& Router::routes_internal_data(int index) const {
  // @@protoc_insertion_point(field_get:serial.Router.routes_internal_data)
  return _internal_routes_internal_data(index);
}
inline ::serial::RoutesInternalData* Router::_internal_add_routes_internal_data() {
  return routes_internal_data_.Add();
}
inline ::serial::RoutesInternalData* Router::add_routes_internal_data() {
  ::serial::RoutesInternalData* _add = _internal_add_routes_internal_data();
  // @@protoc_insertion_point(field_add:serial.Router.routes_internal_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::serial::RoutesInternalData >&
Router::routes_internal_data() const {
  // @@protoc_insertion_point(field_list:serial.Router.routes_internal_data)
  return routes_internal_data_;
}

// -------------------------------------------------------------------

// WaitEdge

// string stop_name = 1;
inline void WaitEdge::clear_stop_name() {
  stop_name_.ClearToEmpty();
}
inline const std::string& WaitEdge::stop_name() const {
  // @@protoc_insertion_point(field_get:serial.WaitEdge.stop_name)
  return _internal_stop_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WaitEdge::set_stop_name(ArgT0&& arg0, ArgT... args) {
 
 stop_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:serial.WaitEdge.stop_name)
}
inline std::string* WaitEdge::mutable_stop_name() {
  std::string* _s = _internal_mutable_stop_name();
  // @@protoc_insertion_point(field_mutable:serial.WaitEdge.stop_name)
  return _s;
}
inline const std::string& WaitEdge::_internal_stop_name() const {
  return stop_name_.Get();
}
inline void WaitEdge::_internal_set_stop_name(const std::string& value) {
  
  stop_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WaitEdge::_internal_mutable_stop_name() {
  
  return stop_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WaitEdge::release_stop_name() {
  // @@protoc_insertion_point(field_release:serial.WaitEdge.stop_name)
  return stop_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WaitEdge::set_allocated_stop_name(std::string* stop_name) {
  if (stop_name != nullptr) {
    
  } else {
    
  }
  stop_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stop_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:serial.WaitEdge.stop_name)
}

// double time = 2;
inline void WaitEdge::clear_time() {
  time_ = 0;
}
inline double WaitEdge::_internal_time() const {
  return time_;
}
inline double WaitEdge::time() const {
  // @@protoc_insertion_point(field_get:serial.WaitEdge.time)
  return _internal_time();
}
inline void WaitEdge::_internal_set_time(double value) {
  
  time_ = value;
}
inline void WaitEdge::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:serial.WaitEdge.time)
}

// -------------------------------------------------------------------

// StopGraphContain

// uint32 start_waiting = 2;
inline void StopGraphContain::clear_start_waiting() {
  start_waiting_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StopGraphContain::_internal_start_waiting() const {
  return start_waiting_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StopGraphContain::start_waiting() const {
  // @@protoc_insertion_point(field_get:serial.StopGraphContain.start_waiting)
  return _internal_start_waiting();
}
inline void StopGraphContain::_internal_set_start_waiting(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  start_waiting_ = value;
}
inline void StopGraphContain::set_start_waiting(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_start_waiting(value);
  // @@protoc_insertion_point(field_set:serial.StopGraphContain.start_waiting)
}

// uint32 end_waiting = 3;
inline void StopGraphContain::clear_end_waiting() {
  end_waiting_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StopGraphContain::_internal_end_waiting() const {
  return end_waiting_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 StopGraphContain::end_waiting() const {
  // @@protoc_insertion_point(field_get:serial.StopGraphContain.end_waiting)
  return _internal_end_waiting();
}
inline void StopGraphContain::_internal_set_end_waiting(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  end_waiting_ = value;
}
inline void StopGraphContain::set_end_waiting(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_end_waiting(value);
  // @@protoc_insertion_point(field_set:serial.StopGraphContain.end_waiting)
}

// -------------------------------------------------------------------

// BusEdge

// string bus_name = 1;
inline void BusEdge::clear_bus_name() {
  bus_name_.ClearToEmpty();
}
inline const std::string& BusEdge::bus_name() const {
  // @@protoc_insertion_point(field_get:serial.BusEdge.bus_name)
  return _internal_bus_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BusEdge::set_bus_name(ArgT0&& arg0, ArgT... args) {
 
 bus_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:serial.BusEdge.bus_name)
}
inline std::string* BusEdge::mutable_bus_name() {
  std::string* _s = _internal_mutable_bus_name();
  // @@protoc_insertion_point(field_mutable:serial.BusEdge.bus_name)
  return _s;
}
inline const std::string& BusEdge::_internal_bus_name() const {
  return bus_name_.Get();
}
inline void BusEdge::_internal_set_bus_name(const std::string& value) {
  
  bus_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BusEdge::_internal_mutable_bus_name() {
  
  return bus_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BusEdge::release_bus_name() {
  // @@protoc_insertion_point(field_release:serial.BusEdge.bus_name)
  return bus_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BusEdge::set_allocated_bus_name(std::string* bus_name) {
  if (bus_name != nullptr) {
    
  } else {
    
  }
  bus_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bus_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:serial.BusEdge.bus_name)
}

// uint32 span_count = 2;
inline void BusEdge::clear_span_count() {
  span_count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BusEdge::_internal_span_count() const {
  return span_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BusEdge::span_count() const {
  // @@protoc_insertion_point(field_get:serial.BusEdge.span_count)
  return _internal_span_count();
}
inline void BusEdge::_internal_set_span_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  span_count_ = value;
}
inline void BusEdge::set_span_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_span_count(value);
  // @@protoc_insertion_point(field_set:serial.BusEdge.span_count)
}

// double time = 3;
inline void BusEdge::clear_time() {
  time_ = 0;
}
inline double BusEdge::_internal_time() const {
  return time_;
}
inline double BusEdge::time() const {
  // @@protoc_insertion_point(field_get:serial.BusEdge.time)
  return _internal_time();
}
inline void BusEdge::_internal_set_time(double value) {
  
  time_ = value;
}
inline void BusEdge::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:serial.BusEdge.time)
}

// -------------------------------------------------------------------

// EdgeInfo

// .serial.WaitEdge w_e = 1;
inline bool EdgeInfo::_internal_has_w_e() const {
  return info_case() == kWE;
}
inline bool EdgeInfo::has_w_e() const {
  return _internal_has_w_e();
}
inline void EdgeInfo::set_has_w_e() {
  _oneof_case_[0] = kWE;
}
inline void EdgeInfo::clear_w_e() {
  if (_internal_has_w_e()) {
    if (GetArenaForAllocation() == nullptr) {
      delete info_.w_e_;
    }
    clear_has_info();
  }
}
inline ::serial::WaitEdge* EdgeInfo::release_w_e() {
  // @@protoc_insertion_point(field_release:serial.EdgeInfo.w_e)
  if (_internal_has_w_e()) {
    clear_has_info();
      ::serial::WaitEdge* temp = info_.w_e_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    info_.w_e_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::serial::WaitEdge& EdgeInfo::_internal_w_e() const {
  return _internal_has_w_e()
      ? *info_.w_e_
      : reinterpret_cast< ::serial::WaitEdge&>(::serial::_WaitEdge_default_instance_);
}
inline const ::serial::WaitEdge& EdgeInfo::w_e() const {
  // @@protoc_insertion_point(field_get:serial.EdgeInfo.w_e)
  return _internal_w_e();
}
inline ::serial::WaitEdge* EdgeInfo::unsafe_arena_release_w_e() {
  // @@protoc_insertion_point(field_unsafe_arena_release:serial.EdgeInfo.w_e)
  if (_internal_has_w_e()) {
    clear_has_info();
    ::serial::WaitEdge* temp = info_.w_e_;
    info_.w_e_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EdgeInfo::unsafe_arena_set_allocated_w_e(::serial::WaitEdge* w_e) {
  clear_info();
  if (w_e) {
    set_has_w_e();
    info_.w_e_ = w_e;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serial.EdgeInfo.w_e)
}
inline ::serial::WaitEdge* EdgeInfo::_internal_mutable_w_e() {
  if (!_internal_has_w_e()) {
    clear_info();
    set_has_w_e();
    info_.w_e_ = CreateMaybeMessage< ::serial::WaitEdge >(GetArenaForAllocation());
  }
  return info_.w_e_;
}
inline ::serial::WaitEdge* EdgeInfo::mutable_w_e() {
  ::serial::WaitEdge* _msg = _internal_mutable_w_e();
  // @@protoc_insertion_point(field_mutable:serial.EdgeInfo.w_e)
  return _msg;
}

// .serial.BusEdge b_e = 2;
inline bool EdgeInfo::_internal_has_b_e() const {
  return info_case() == kBE;
}
inline bool EdgeInfo::has_b_e() const {
  return _internal_has_b_e();
}
inline void EdgeInfo::set_has_b_e() {
  _oneof_case_[0] = kBE;
}
inline void EdgeInfo::clear_b_e() {
  if (_internal_has_b_e()) {
    if (GetArenaForAllocation() == nullptr) {
      delete info_.b_e_;
    }
    clear_has_info();
  }
}
inline ::serial::BusEdge* EdgeInfo::release_b_e() {
  // @@protoc_insertion_point(field_release:serial.EdgeInfo.b_e)
  if (_internal_has_b_e()) {
    clear_has_info();
      ::serial::BusEdge* temp = info_.b_e_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    info_.b_e_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::serial::BusEdge& EdgeInfo::_internal_b_e() const {
  return _internal_has_b_e()
      ? *info_.b_e_
      : reinterpret_cast< ::serial::BusEdge&>(::serial::_BusEdge_default_instance_);
}
inline const ::serial::BusEdge& EdgeInfo::b_e() const {
  // @@protoc_insertion_point(field_get:serial.EdgeInfo.b_e)
  return _internal_b_e();
}
inline ::serial::BusEdge* EdgeInfo::unsafe_arena_release_b_e() {
  // @@protoc_insertion_point(field_unsafe_arena_release:serial.EdgeInfo.b_e)
  if (_internal_has_b_e()) {
    clear_has_info();
    ::serial::BusEdge* temp = info_.b_e_;
    info_.b_e_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EdgeInfo::unsafe_arena_set_allocated_b_e(::serial::BusEdge* b_e) {
  clear_info();
  if (b_e) {
    set_has_b_e();
    info_.b_e_ = b_e;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serial.EdgeInfo.b_e)
}
inline ::serial::BusEdge* EdgeInfo::_internal_mutable_b_e() {
  if (!_internal_has_b_e()) {
    clear_info();
    set_has_b_e();
    info_.b_e_ = CreateMaybeMessage< ::serial::BusEdge >(GetArenaForAllocation());
  }
  return info_.b_e_;
}
inline ::serial::BusEdge* EdgeInfo::mutable_b_e() {
  ::serial::BusEdge* _msg = _internal_mutable_b_e();
  // @@protoc_insertion_point(field_mutable:serial.EdgeInfo.b_e)
  return _msg;
}

inline bool EdgeInfo::has_info() const {
  return info_case() != INFO_NOT_SET;
}
inline void EdgeInfo::clear_has_info() {
  _oneof_case_[0] = INFO_NOT_SET;
}
inline EdgeInfo::InfoCase EdgeInfo::info_case() const {
  return EdgeInfo::InfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TransportRouter

// .serial.RoutingSettings routing_settings = 1;
inline bool TransportRouter::_internal_has_routing_settings() const {
  return this != internal_default_instance() && routing_settings_ != nullptr;
}
inline bool TransportRouter::has_routing_settings() const {
  return _internal_has_routing_settings();
}
inline void TransportRouter::clear_routing_settings() {
  if (GetArenaForAllocation() == nullptr && routing_settings_ != nullptr) {
    delete routing_settings_;
  }
  routing_settings_ = nullptr;
}
inline const ::serial::RoutingSettings& TransportRouter::_internal_routing_settings() const {
  const ::serial::RoutingSettings* p = routing_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::serial::RoutingSettings&>(
      ::serial::_RoutingSettings_default_instance_);
}
inline const ::serial::RoutingSettings& TransportRouter::routing_settings() const {
  // @@protoc_insertion_point(field_get:serial.TransportRouter.routing_settings)
  return _internal_routing_settings();
}
inline void TransportRouter::unsafe_arena_set_allocated_routing_settings(
    ::serial::RoutingSettings* routing_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_settings_);
  }
  routing_settings_ = routing_settings;
  if (routing_settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serial.TransportRouter.routing_settings)
}
inline ::serial::RoutingSettings* TransportRouter::release_routing_settings() {
  
  ::serial::RoutingSettings* temp = routing_settings_;
  routing_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serial::RoutingSettings* TransportRouter::unsafe_arena_release_routing_settings() {
  // @@protoc_insertion_point(field_release:serial.TransportRouter.routing_settings)
  
  ::serial::RoutingSettings* temp = routing_settings_;
  routing_settings_ = nullptr;
  return temp;
}
inline ::serial::RoutingSettings* TransportRouter::_internal_mutable_routing_settings() {
  
  if (routing_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::serial::RoutingSettings>(GetArenaForAllocation());
    routing_settings_ = p;
  }
  return routing_settings_;
}
inline ::serial::RoutingSettings* TransportRouter::mutable_routing_settings() {
  ::serial::RoutingSettings* _msg = _internal_mutable_routing_settings();
  // @@protoc_insertion_point(field_mutable:serial.TransportRouter.routing_settings)
  return _msg;
}
inline void TransportRouter::set_allocated_routing_settings(::serial::RoutingSettings* routing_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete routing_settings_;
  }
  if (routing_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serial::RoutingSettings>::GetOwningArena(routing_settings);
    if (message_arena != submessage_arena) {
      routing_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing_settings, submessage_arena);
    }
    
  } else {
    
  }
  routing_settings_ = routing_settings;
  // @@protoc_insertion_point(field_set_allocated:serial.TransportRouter.routing_settings)
}

// .serial.Router router = 2;
inline bool TransportRouter::_internal_has_router() const {
  return this != internal_default_instance() && router_ != nullptr;
}
inline bool TransportRouter::has_router() const {
  return _internal_has_router();
}
inline void TransportRouter::clear_router() {
  if (GetArenaForAllocation() == nullptr && router_ != nullptr) {
    delete router_;
  }
  router_ = nullptr;
}
inline const ::serial::Router& TransportRouter::_internal_router() const {
  const ::serial::Router* p = router_;
  return p != nullptr ? *p : reinterpret_cast<const ::serial::Router&>(
      ::serial::_Router_default_instance_);
}
inline const ::serial::Router& TransportRouter::router() const {
  // @@protoc_insertion_point(field_get:serial.TransportRouter.router)
  return _internal_router();
}
inline void TransportRouter::unsafe_arena_set_allocated_router(
    ::serial::Router* router) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(router_);
  }
  router_ = router;
  if (router) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:serial.TransportRouter.router)
}
inline ::serial::Router* TransportRouter::release_router() {
  
  ::serial::Router* temp = router_;
  router_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::serial::Router* TransportRouter::unsafe_arena_release_router() {
  // @@protoc_insertion_point(field_release:serial.TransportRouter.router)
  
  ::serial::Router* temp = router_;
  router_ = nullptr;
  return temp;
}
inline ::serial::Router* TransportRouter::_internal_mutable_router() {
  
  if (router_ == nullptr) {
    auto* p = CreateMaybeMessage<::serial::Router>(GetArenaForAllocation());
    router_ = p;
  }
  return router_;
}
inline ::serial::Router* TransportRouter::mutable_router() {
  ::serial::Router* _msg = _internal_mutable_router();
  // @@protoc_insertion_point(field_mutable:serial.TransportRouter.router)
  return _msg;
}
inline void TransportRouter::set_allocated_router(::serial::Router* router) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete router_;
  }
  if (router) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::serial::Router>::GetOwningArena(router);
    if (message_arena != submessage_arena) {
      router = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, router, submessage_arena);
    }
    
  } else {
    
  }
  router_ = router;
  // @@protoc_insertion_point(field_set_allocated:serial.TransportRouter.router)
}

// map<uint32, .serial.EdgeInfo> edge_info_by_edge_id = 3;
inline int TransportRouter::_internal_edge_info_by_edge_id_size() const {
  return edge_info_by_edge_id_.size();
}
inline int TransportRouter::edge_info_by_edge_id_size() const {
  return _internal_edge_info_by_edge_id_size();
}
inline void TransportRouter::clear_edge_info_by_edge_id() {
  edge_info_by_edge_id_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo >&
TransportRouter::_internal_edge_info_by_edge_id() const {
  return edge_info_by_edge_id_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo >&
TransportRouter::edge_info_by_edge_id() const {
  // @@protoc_insertion_point(field_map:serial.TransportRouter.edge_info_by_edge_id)
  return _internal_edge_info_by_edge_id();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo >*
TransportRouter::_internal_mutable_edge_info_by_edge_id() {
  return edge_info_by_edge_id_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::serial::EdgeInfo >*
TransportRouter::mutable_edge_info_by_edge_id() {
  // @@protoc_insertion_point(field_mutable_map:serial.TransportRouter.edge_info_by_edge_id)
  return _internal_mutable_edge_info_by_edge_id();
}

// map<string, .serial.StopGraphContain> stops_vertex_cont = 4;
inline int TransportRouter::_internal_stops_vertex_cont_size() const {
  return stops_vertex_cont_.size();
}
inline int TransportRouter::stops_vertex_cont_size() const {
  return _internal_stops_vertex_cont_size();
}
inline void TransportRouter::clear_stops_vertex_cont() {
  stops_vertex_cont_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::serial::StopGraphContain >&
TransportRouter::_internal_stops_vertex_cont() const {
  return stops_vertex_cont_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::serial::StopGraphContain >&
TransportRouter::stops_vertex_cont() const {
  // @@protoc_insertion_point(field_map:serial.TransportRouter.stops_vertex_cont)
  return _internal_stops_vertex_cont();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::serial::StopGraphContain >*
TransportRouter::_internal_mutable_stops_vertex_cont() {
  return stops_vertex_cont_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::serial::StopGraphContain >*
TransportRouter::mutable_stops_vertex_cont() {
  // @@protoc_insertion_point(field_mutable_map:serial.TransportRouter.stops_vertex_cont)
  return _internal_mutable_stops_vertex_cont();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace serial

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transport_5frouter_2eproto
